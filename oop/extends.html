
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 
        继承，是基于类创建其他类的能力。通过继承，我们可以先定义父类，然后再定义子类，子类继承父类的所有属性和方法。
        
        1.一个子类只能继承一个父类，不可以继承多个父类。虽然确实有相应的技巧来解决这个问题。
        2.你可以根据需求扩展继承链，设置父类、祖父类、太祖父类等。
        3.如果子类从父类继承一些属性，必须 首先 使用super()函数并将父类属性传参，然后再设定子类自己的属性。
        4.在继承的时候，所有父类的方法和属性都会被子类继承，我们并不能决定继承哪些，不继承哪些。
        5.可以覆盖掉
     -->


     <!-- 

        封装。
        封装代表对象有“决定”将什么信息暴露在“外部”的能力。封装通过公共和私有属性/方法来实现。
        在js中所有对象的属性和方法默认为公共的。“公共”意味着我们可以在函数体外部获取对象的属性和方法。

        首先我们要声明一个私有属性，通常使用 “#” 打头


      -->

      <!-- 
        抽象
        抽象是一个原则，规定了一个类只能代表和问题上下文相关的信息。简言之，只暴露需要在外部使用的属性和方法，如果不需要使用，就不要暴露。
        这个原则和封装紧密相关，因为在封装中，我们使用公共和私有属性/方法来决定应该暴露哪些信息。
       -->

       <!-- 
        多态
        最后就是多态这个概念。多态意味着“多种形态”，实际上这是一个简单的概念，表示的在不同的特定条件下使用一种方法返回不同的值。
        == 这是因为我们在每一个子类实例化的时候，传入了不一样的参数。这是一种形式的多态—— 基于参数的多态。
        == 另一种多态是基于继承的多态， 指的是子类覆盖了父类的属性和方法。
        -->
     <script>

        // 一个方法，
        const addAblity = function(obj){
            obj.fly=function(){
                console.log( "获得的其他能力。。");
            }
        }
    

        // 创建公共类
        class Total{
            constructor(name) {
                this.name = name
            }
            say = function(){
                console.log(this.name+"说话了。。")
            }
        }
         //创建Player类
         class Player extends Total {
            #hideProto // 首先我们要声明一个私有属性，通常是用 “#” 打头
                constructor (name,age,sex,hideProto){
                   super(name)
                    this.species = "player"
                    this.age = age 
                    this.sex = sex
                    this.#hideProto = hideProto
                }
                //对象方法
                move = function(){
                console.log(this.name+"移动。。。。。");
             }
            }
            // 创建Army类
            class Army extends Total{
                constructor(name){
                    super(name)
                    this.species = "army" 
                    
                }

                // 对象方法
                move = function(){
                console.log(this.name+"移动。。。。。");
                }
                attack = function(){
                console.log(this.name+"发动了攻击。。。");
                }
            }

            // 创建Npc类
            class Npc{
                constructor(name){
                    this.species = "npc" 
                    this.name = name  
                }
                // 对象方法
                say = function(){
                console.log("想着深渊和目标。。。。。");
            }
            }

            // 通过类实例化我们的对象
            const player1 = new Player('哥哥',23,'男','私有属性');
            const player2 = new Player('妹妹',23,'女');
            const army1 = new Army('丘丘人1号');
            const army2 = new Army('丘丘人2号');
            const npc1 = new Npc('凯瑟琳');
            const npc2 = new Npc('安博');
            // 调用，测试
            console.log(player1.name);
            player1.say();
            console.log(army1.name);
            console.log(player1.species);//output:player
            player1.move();//output:哥哥移动。。。。。
            console.log(army1.name);//output:丘丘人1号
            army1.attack();//output:丘丘人1号发动了攻击。。。
            console.log(npc1.name+npc1.species);//output:凯瑟琳npc
            npc1.say();//output:想着深渊和目标。。。。。

            console.log(player1);//不显示私有属性或方法
         //获得的新能力。
            addAblity(npc1);
            npc1.fly();
     </script>
</body>
</html>