<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>ES6新特性</h1>
    <p id="demo"></p>

    <script>
        // class People {
        //     constructor(name,age,sex){
        //         this.name = name;
        //         this.age = age;
        //         this.sex = sex;
        //     }
            // move = function(){}

            // 使用模板字符串
            // move(){
                // console.log(`这是一个es6的新特性    
                // 模板字符串
                // 好像还可以换行${this.name}引用元素的方式也变化了
                // ${this.age}直接用美元符号和大括号界定位置就好     不知道空格可以显示吗${this.sex}`);
            // }

            // 箭头函数
            // move = () =>{
            //     console.log(`这是一个es6的新特性    
            //     模板字符串
            //     好像还可以换行${this.name}引用元素的方式也变化了
            //     ${this.age}直接用美元符号和大括号界定位置就好     不知道空格可以显示吗${this.sex}`);
            // }
            // move(){
            //     console.log("这是一个es6的新特性\
            //     \
            //     就看见了 " 
            //     +this.name+ "\
            //     换行")
            // }
        // }


        // let tom = new People('tom',55,'男');
        // let a = document.getElementById('demo');
        // let b = tom.move();
        // a.innerText="ajjf  jd/jj   /  jsdja ";

        // var sy = Symbol('test');
        // var sy1 = Symbol('test');
        // console.log(typeof sy);   //'symbol'
        // console.log(sy === sy1);   //false
        // console.log(sy == sy1);   //false
        // var sy2 = new Symbol('test');   //error : Symbol is not a constructor

        //解构赋值
        // [a,b,...re] = [1,3,5,6,7,89,0];
        // console.log(a);
        // console.log(b);
        // console.log(...re);

//         const numbers = [];
// const obj = { a: 1, b: 2 };
// ({ a: numbers[0], b: numbers[1] } = obj);

// const obj = { a: 1, b: { c: 2 } };
// const { f, b: { c: d } } = obj;

// const obj = { a: 1, b: 2 };
// const { f, j } = obj;



// promise.异步处理
// 通过新建一个 Promise 对象好像并没有看出它怎样 "更加优雅地书写复杂的异步任务"。我们之前遇到的异步任务都是一次异步，如果需要多次调用异步函数呢？例如，如果我想分三次输出字符串，第一次间隔 1 秒，第二次间隔 4 秒，第三次间隔 3 秒：

// setTimeout(function () {
//     console.log("First");
//     setTimeout(function () {
//         console.log("Second");
//         setTimeout(function () {
//             console.log("Third");
//         }, 3000);
//     }, 4000);
// }, 1000);

// 这段程序实现了这个功能，但是它是用 "函数瀑布" 来实现的。可想而知，在一个复杂的程序当中，用 "函数瀑布" 实现的程序无论是维护还是异常处理都是一件特别繁琐的事情，而且会让缩进格式变得非常冗赘。
// 
// 现在我们用 Promise 来实现同样的功能：
// new Promise((resolve,reject) =>{
//     setTimeout(() => {
//         console.log("first");
//         resolve();
//     }, 1000);
// }).then(() => {
//      new Promise((resolve, reject) => {
//     setTimeout(() => {
//         console.log("second");
//         resolve();
//     }, 3000);
// })}).then(() =>{
//     setTimeout(() => {
//         console.log("three");
//     }, 4000);
// });

// const promise = new Promise((resolve, reject) => {
//   // 异步操作
//   setTimeout(() => {
//     if (Math.random() < 0.5) {
//       resolve('success');
//     } else {
//       reject('error');
//     }
//   }, 1000);
// });

// promise.then(result => {
//   console.log(result);
// }).catch(error => {
//   console.log(error);
// }).finally(() =>{
//     console.log("无论如何都要执行的代码");
// });

// new Promise(function (resolve, reject) {
//     console.log(1111);
//     resolve(2222);
// }).then(function (value) {
//     console.log(value);
//     return 3333;
// }).then(function (value) {
//     console.log(value);
//     throw "cuowue";//抛出一个错误，catch会收到。
// }).catch(function (err) {
//     console.log(err);
// });

//将一个异步处理的代码进行了封装。
// function print(delay, message) {
//     return new Promise(function (resolve, reject) {
//         setTimeout(function () {
//             console.log(message);
//             resolve();
//         }, delay);
//     });
// }


const obj = {name:"bob", age: 23}

//  // 首先是根据属性获取值
//  const {name, age} = obj
//  console.log(name)
//  console.log(age)
 // 如果外面有一个相同的属性名，可以使用重命名的方式获取，并且可以设置默认值
 const {name:s, age} = obj
 let name = 'reset'
 console.log(name)
 console.log(age)

    </script>
</body>
</html>